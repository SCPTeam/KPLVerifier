/*
 * generated by Xtext
 */
package unige.dibris.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import unige.dibris.kPL.Assign;
import unige.dibris.kPL.Barrier;
import unige.dibris.kPL.BinaryExpr;
import unige.dibris.kPL.Block;
import unige.dibris.kPL.Branch;
import unige.dibris.kPL.Decl;
import unige.dibris.kPL.GSwitch;
import unige.dibris.kPL.Gid;
import unige.dibris.kPL.Invoke;
import unige.dibris.kPL.KPLPackage;
import unige.dibris.kPL.Kernel;
import unige.dibris.kPL.LSwitch;
import unige.dibris.kPL.Lid;
import unige.dibris.kPL.Loop;
import unige.dibris.kPL.Procedure;
import unige.dibris.kPL.Read;
import unige.dibris.kPL.Skip;
import unige.dibris.kPL.Val;
import unige.dibris.kPL.Var;
import unige.dibris.kPL.Write;
import unige.dibris.services.KPLGrammarAccess;

@SuppressWarnings("all")
public class KPLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KPLGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == KPLPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case KPLPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case KPLPackage.BARRIER:
				sequence_Barrier(context, (Barrier) semanticObject); 
				return; 
			case KPLPackage.BINARY_EXPR:
				if(context == grammarAccess.getAddAccess().getBinaryExprLeftAction_1_1_0()) {
					sequence_Add_BinaryExpr_1_1_0(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAddRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getMulRule() ||
				   context == grammarAccess.getPrimaryExpressionRule()) {
					sequence_Add_Mul(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getMulAccess().getBinaryExprLeftAction_1_1_0()) {
					sequence_Mul_BinaryExpr_1_1_0(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else break;
			case KPLPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case KPLPackage.BRANCH:
				sequence_Branch(context, (Branch) semanticObject); 
				return; 
			case KPLPackage.DECL:
				sequence_Decl(context, (Decl) semanticObject); 
				return; 
			case KPLPackage.GSWITCH:
				sequence_GSwitch(context, (GSwitch) semanticObject); 
				return; 
			case KPLPackage.GID:
				sequence_Gid(context, (Gid) semanticObject); 
				return; 
			case KPLPackage.INVOKE:
				sequence_Invoke(context, (Invoke) semanticObject); 
				return; 
			case KPLPackage.KERNEL:
				sequence_Kernel(context, (Kernel) semanticObject); 
				return; 
			case KPLPackage.LSWITCH:
				sequence_LSwitch(context, (LSwitch) semanticObject); 
				return; 
			case KPLPackage.LID:
				sequence_Lid(context, (Lid) semanticObject); 
				return; 
			case KPLPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case KPLPackage.PROCEDURE:
				sequence_Procedure(context, (Procedure) semanticObject); 
				return; 
			case KPLPackage.READ:
				sequence_Read(context, (Read) semanticObject); 
				return; 
			case KPLPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case KPLPackage.VAL:
				sequence_Val(context, (Val) semanticObject); 
				return; 
			case KPLPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case KPLPackage.WRITE:
				sequence_Write(context, (Write) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=Add_BinaryExpr_1_1_0 (op='+' | op='-') right=Mul)
	 */
	protected void sequence_Add_BinaryExpr_1_1_0(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((left=Mul_BinaryExpr_1_1_0 (op='*' | op='/') right=PrimaryExpression) | (left=Add_BinaryExpr_1_1_0 (op='+' | op='-') right=Mul))
	 */
	protected void sequence_Add_Mul(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (var=ID exp=Expression)
	 */
	protected void sequence_Assign(EObject context, Assign semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.ASSIGN__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.ASSIGN__VAR));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.ASSIGN__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.ASSIGN__EXP));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignAccess().getVarIDTerminalRuleCall_1_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getAssignAccess().getExpExpressionParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {Barrier}
	 */
	protected void sequence_Barrier(EObject context, Barrier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     stats+=Statement+
	 */
	protected void sequence_Block(EObject context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (guard=Expression left=Statement right=Statement)
	 */
	protected void sequence_Branch(EObject context, Branch semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.BRANCH__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.BRANCH__GUARD));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.BRANCH__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.BRANCH__LEFT));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.BRANCH__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.BRANCH__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBranchAccess().getGuardExpressionParserRuleCall_2_0(), semanticObject.getGuard());
		feeder.accept(grammarAccess.getBranchAccess().getLeftStatementParserRuleCall_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBranchAccess().getRightStatementParserRuleCall_6_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (var=ID body=Statement)
	 */
	protected void sequence_Decl(EObject context, Decl semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.DECL__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.DECL__VAR));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.DECL__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.DECL__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDeclAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getDeclAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (cases+=INT stats+=Statement)+
	 */
	protected void sequence_GSwitch(EObject context, GSwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {Gid}
	 */
	protected void sequence_Gid(EObject context, Gid semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (fun=ID arg=Expression)
	 */
	protected void sequence_Invoke(EObject context, Invoke semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.INVOKE__FUN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.INVOKE__FUN));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.INVOKE__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.INVOKE__ARG));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeAccess().getFunIDTerminalRuleCall_1_0(), semanticObject.getFun());
		feeder.accept(grammarAccess.getInvokeAccess().getArgExpressionParserRuleCall_3_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (n=INT m=INT procedures+=Procedure* main=Statement)
	 */
	protected void sequence_Kernel(EObject context, Kernel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (cases+=INT stats+=Statement)+
	 */
	protected void sequence_LSwitch(EObject context, LSwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {Lid}
	 */
	protected void sequence_Lid(EObject context, Lid semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (guard=Expression body=Statement)
	 */
	protected void sequence_Loop(EObject context, Loop semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.LOOP__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.LOOP__GUARD));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.LOOP__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.LOOP__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLoopAccess().getGuardExpressionParserRuleCall_2_0(), semanticObject.getGuard());
		feeder.accept(grammarAccess.getLoopAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=Mul_BinaryExpr_1_1_0 (op='*' | op='/') right=PrimaryExpression)
	 */
	protected void sequence_Mul_BinaryExpr_1_1_0(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (z=ID x=ID body=Statement)
	 */
	protected void sequence_Procedure(EObject context, Procedure semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.PROCEDURE__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.PROCEDURE__Z));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.PROCEDURE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.PROCEDURE__X));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.PROCEDURE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.PROCEDURE__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProcedureAccess().getZIDTerminalRuleCall_1_0(), semanticObject.getZ());
		feeder.accept(grammarAccess.getProcedureAccess().getXIDTerminalRuleCall_2_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getProcedureAccess().getBodyStatementParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID loc=INT)
	 */
	protected void sequence_Read(EObject context, Read semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.READ__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.READ__NAME));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.READ__LOC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.READ__LOC));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReadAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getReadAccess().getLocINTTerminalRuleCall_5_0(), semanticObject.getLoc());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {Skip}
	 */
	protected void sequence_Skip(EObject context, Skip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=INT
	 */
	protected void sequence_Val(EObject context, Val semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.VAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.VAL__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValAccess().getValINTTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Var(EObject context, Var semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.VAR__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVarAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (loc=INT exp=Expression)
	 */
	protected void sequence_Write(EObject context, Write semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.WRITE__LOC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.WRITE__LOC));
			if(transientValues.isValueTransient(semanticObject, KPLPackage.Literals.WRITE__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KPLPackage.Literals.WRITE__EXP));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWriteAccess().getLocINTTerminalRuleCall_3_0(), semanticObject.getLoc());
		feeder.accept(grammarAccess.getWriteAccess().getExpExpressionParserRuleCall_5_0(), semanticObject.getExp());
		feeder.finish();
	}
}
